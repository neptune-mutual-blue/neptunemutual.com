/* ----------------------------------------- */
// Do not edit this file
/* ----------------------------------------- */

import Enumerable from 'linq'
import path from 'path'

import { Api } from '../../types/enum'
import * as io from '../../util/io'
import { config } from './config'

const getApi = async <T>(api: Api): Promise<ApiResult<T>> => {
  if (!Object.values(Api).includes(api)) {
    throw new Error(`Invalid type ${api}`)
  }

  const file = path.join(config.root, `${api}.json`)
  const contents = await io.readFile(file)

  const result = JSON.parse(contents)
  return result
}

const getContracts = async (api: (Api.Contract | Api.ContractArbitrum | Api.ContractMumbai | Api.ContractBSC)): Promise<ApiResponse<ProtocolContracts>> => {
  const contracts = [Api.Contract, Api.ContractArbitrum, Api.ContractMumbai, Api.ContractBSC]
  if (!contracts.includes(api)) {
    throw new Error(`Invalid type ${api} for contract`)
  }

  const file = path.join(config.root, `${api}.json`)
  const contents = await io.readFile(file)

  const result = JSON.parse(contents)
  return result
}

const getEnumerable = async <T>(api: Api, limit: number, skip: number): Promise<T[]> => {
  const result = await getApi<T>(api)

  let enumerable = Enumerable.from(result.docs)

  if (limit > 0) {
    enumerable = enumerable.take(limit)
  }

  if (skip > 0) {
    enumerable = enumerable.skip(skip)
  }

  const enumerated = enumerable.toArray()

  return enumerated
}

const getPaginated = async<T>(api: Api, pageSize: number = 12): Promise<PaginatedResult<T>> => {
  const { docs } = await getApi<T>(api)

  const records = docs.length
  const totalPages = Math.ceil(records / pageSize)

  const result: PaginatedResult<T> = {
    records,
    totalPages,
    pageSize,
    pages: {
    }
  }

  for (let i = 0; i < totalPages; i++) {
    const prop = (i + 1).toString()
    const start = i * pageSize
    const end = start + pageSize <= records ? start + pageSize : records

    result.pages[prop as keyof PaginatedResult<T>] = docs.slice(start, end)
  }

  return result
}

const getPaginatedByTags = async (api: Api, pageSize: number = 12): Promise<Array<PaginatedByTagsResult<Article>>> => {
  const { docs } = await getApi<Article>(api)

  const allTags = docs.map((doc) => doc.tags).flat().filter((tag) => tag !== undefined)
  const uniqueTags = [...new Map(allTags.map((tag: any) => [tag.id, tag])).values()]

  const result = uniqueTags.map((tag: any) => {
    const filteredDocs = docs.filter((doc: any) => {
      if (doc.tags === undefined || doc.tags === null) {
        console.log('No tags found for doc:', doc.id)

        return false
      }

      const matchedTag = doc.tags.find((x: any) => x.slug === tag.slug)
      return matchedTag
    })

    const records = filteredDocs.length
    const totalPages = Math.ceil(records / pageSize)

    const _result: PaginatedByTagsResult<Article> = {
      tag,
      records,
      totalPages,
      pageSize,
      pages: {
      }
    }

    for (let i = 0; i < totalPages; i++) {
      const prop = (i + 1).toString()
      const start = i * pageSize
      const end = start + pageSize <= records ? start + pageSize : records

      _result.pages[prop as keyof PaginatedByTagsResult<Article>] = filteredDocs.slice(start, end)
    }

    return _result
  })

  return result
}

export { getApi, getContracts, getEnumerable, getPaginated, getPaginatedByTags }
